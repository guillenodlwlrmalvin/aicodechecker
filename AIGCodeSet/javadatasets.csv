code,label,topic,complexity,description
"public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(""Hello, World!"");
    }
}",Human,Basic Java Program,Beginner,Simple hello world program
"public class Calculator {
    public int add(int a, int b) { return a + b; }
    public int subtract(int a, int b) { return a - b; }
    public int multiply(int a, int b) { return a * b; }
    public double divide(int a, int b) { return (double) a / b; }
}",Human,Methods and Operations,Beginner,Basic calculator with arithmetic operations
"import java.util.Scanner;
public class UserInput {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter your name: "");
        String name = sc.nextLine();
        System.out.println(""Hello, "" + name);
        sc.close();
    }
}",Human,Input/Output,Beginner,Reading user input with Scanner
"public class DataTypes {
    public static void main(String[] args) {
        int age = 25;
        double salary = 50000.50;
        char grade = 'A';
        boolean isActive = true;
        String name = ""John"";
        System.out.println(""Age: "" + age);
        System.out.println(""Salary: "" + salary);
    }
}",AI,Data Types,Beginner,Demonstration of primitive data types
"public class ConditionalDemo {
    public static void main(String[] args) {
        int score = 85;
        if (score >= 90) {
            System.out.println(""Grade: A"");
        } else if (score >= 80) {
            System.out.println(""Grade: B"");
        } else {
            System.out.println(""Grade: C"");
        }
    }
}",AI,Control Structures - Conditionals,Beginner,If-else conditional statements
"public class SwitchDemo {
    public static void main(String[] args) {
        int day = 3;
        switch(day) {
            case 1: System.out.println(""Monday""); break;
            case 2: System.out.println(""Tuesday""); break;
            case 3: System.out.println(""Wednesday""); break;
            default: System.out.println(""Invalid day"");
        }
    }
}",Human,Control Structures - Switch,Beginner,Switch statement for day selection
"public class ForLoopDemo {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            System.out.println(""Iteration: "" + i);
        }
    }
}",AI,Control Structures - Loops,Beginner,Basic for loop iteration
"public class WhileLoopDemo {
    public static void main(String[] args) {
        int count = 0;
        while (count < 5) {
            System.out.println(""Count: "" + count);
            count++;
        }
    }
}",Human,Control Structures - Loops,Beginner,While loop with counter
"public class DoWhileDemo {
    public static void main(String[] args) {
        int num = 1;
        do {
            System.out.println(""Number: "" + num);
            num++;
        } while (num <= 3);
    }
}",AI,Control Structures - Loops,Beginner,Do-while loop example
"public class ArrayDemo {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        for (int i = 0; i < numbers.length; i++) {
            System.out.println(""Element "" + i + "": "" + numbers[i]);
        }
    }
}",Human,Arrays - Single Dimensional,Intermediate,Array declaration and traversal
"public class MultiDimensionalArray {
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j] + "" "");
            }
            System.out.println();
        }
    }
}",AI,Arrays - Multi Dimensional,Intermediate,2D array matrix traversal
"public class EnhancedForLoop {
    public static void main(String[] args) {
        String[] fruits = {""Apple"", ""Banana"", ""Cherry""};
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}",Human,Arrays - Enhanced For Loop,Intermediate,For-each loop with arrays
"class Student {
    private String name;
    private int age;
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void display() {
        System.out.println(""Name: "" + name + "", Age: "" + age);
    }
}",AI,Classes and Objects,Intermediate,Basic class with constructor and method
"class BankAccount {
    private double balance;
    
    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }
    
    public void deposit(double amount) {
        balance += amount;
    }
    
    public void withdraw(double amount) {
        if (amount <= balance) balance -= amount;
    }
    
    public double getBalance() {
        return balance;
    }
}",Human,Classes and Encapsulation,Intermediate,Encapsulation with private fields
"public class ExceptionDemo {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println(""Error: Division by zero"");
        } finally {
            System.out.println(""Execution completed"");
        }
    }
}",AI,Exception Handling,Intermediate,Try-catch-finally block
"import java.util.ArrayList;
public class ArrayListDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add(""Java"");
        list.add(""Python"");
        list.add(""C++"");
        for (String lang : list) {
            System.out.println(lang);
        }
    }
}",Human,Data Structures - ArrayList,Intermediate,ArrayList basic operations
"class Node {
    int data;
    Node next;
    
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;
    
    public void add(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node temp = head;
            while (temp.next != null) {
                temp = temp.next;
            }
            temp.next = newNode;
        }
    }
}",AI,Data Structures - Linked List,Advanced,Singly linked list implementation
"import java.util.Stack;
public class StackDemo {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println(""Top: "" + stack.peek());
        System.out.println(""Popped: "" + stack.pop());
        System.out.println(""Size: "" + stack.size());
    }
}",Human,Data Structures - Stack,Advanced,Stack operations using Java Collections
"import java.util.LinkedList;
import java.util.Queue;
public class QueueDemo {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.offer(""First"");
        queue.offer(""Second"");
        queue.offer(""Third"");
        System.out.println(""Front: "" + queue.peek());
        System.out.println(""Removed: "" + queue.poll());
    }
}",AI,Data Structures - Queue,Advanced,Queue implementation and operations
"class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class BinaryTree {
    TreeNode root;
    
    public void inorderTraversal(TreeNode node) {
        if (node != null) {
            inorderTraversal(node.left);
            System.out.print(node.value + "" "");
            inorderTraversal(node.right);
        }
    }
}",Human,Data Structures - Binary Tree,Advanced,Binary tree with inorder traversal
"public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}",AI,Algorithms - Bubble Sort,Advanced,Bubble sort implementation
"public class SelectionSort {
    public static void selectionSort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            int minIdx = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            int temp = arr[minIdx];
            arr[minIdx] = arr[i];
            arr[i] = temp;
        }
    }
}",Human,Algorithms - Selection Sort,Advanced,Selection sort algorithm
"public class InsertionSort {
    public static void insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
}",AI,Algorithms - Insertion Sort,Advanced,Insertion sort implementation
"public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;
        int[] L = new int[n1];
        int[] R = new int[n2];
        System.arraycopy(arr, l, L, 0, n1);
        System.arraycopy(arr, m + 1, R, 0, n2);
        int i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) arr[k++] = L[i++];
            else arr[k++] = R[j++];
        }
        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }
}",Human,Algorithms - Merge Sort,Advanced,Merge sort with divide and conquer
"public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}",AI,Algorithms - Quick Sort,Advanced,Quick sort with partitioning
"public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
}",Human,Algorithms - Binary Search,Advanced,Binary search on sorted array
"public class LinearSearch {
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
}",AI,Algorithms - Linear Search,Intermediate,Linear search algorithm
"import java.util.HashMap;
public class HashMapDemo {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put(""Apple"", 100);
        map.put(""Banana"", 200);
        map.put(""Cherry"", 150);
        System.out.println(""Apple price: "" + map.get(""Apple""));
        for (String key : map.keySet()) {
            System.out.println(key + "": "" + map.get(key));
        }
    }
}",Human,Data Structures - HashMap,Advanced,HashMap basic operations
"public class RecursionDemo {
    public static int factorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    public static void main(String[] args) {
        System.out.println(""Factorial of 5: "" + factorial(5));
    }
}",AI,Recursion,Intermediate,Factorial using recursion
"public class FibonacciRecursion {
    public static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.print(fibonacci(i) + "" "");
        }
    }
}",Human,Recursion - Fibonacci,Intermediate,Fibonacci sequence using recursion
"class HashTable {
    private static final int SIZE = 10;
    private String[] keys;
    private Integer[] values;
    
    public HashTable() {
        keys = new String[SIZE];
        values = new Integer[SIZE];
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode() % SIZE);
    }
    
    public void put(String key, int value) {
        int index = hash(key);
        while (keys[index] != null && !keys[index].equals(key)) {
            index = (index + 1) % SIZE;
        }
        keys[index] = key;
        values[index] = value;
    }
    
    public Integer get(String key) {
        int index = hash(key);
        while (keys[index] != null) {
            if (keys[index].equals(key)) return values[index];
            index = (index + 1) % SIZE;
        }
        return null;
    }
}",AI,Data Structures - Hash Table,Advanced,Hash table with linear probing
"import java.util.PriorityQueue;
public class HeapDemo {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.add(5);
        minHeap.add(2);
        minHeap.add(8);
        minHeap.add(1);
        System.out.println(""Min element: "" + minHeap.peek());
        while (!minHeap.isEmpty()) {
            System.out.println(minHeap.poll());
        }
    }
}",Human,Data Structures - Heap,Advanced,Priority queue (min heap) operations
"import java.util.ArrayList;
import java.util.LinkedList;
class Graph {
    private int vertices;
    private LinkedList<Integer>[] adjacencyList;
    
    public Graph(int vertices) {
        this.vertices = vertices;
        adjacencyList = new LinkedList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjacencyList[i] = new LinkedList<>();
        }
    }
    
    public void addEdge(int source, int destination) {
        adjacencyList[source].add(destination);
        adjacencyList[destination].add(source);
    }
    
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print(""Vertex "" + i + "":"");
            for (Integer node : adjacencyList[i]) {
                System.out.print("" -> "" + node);
            }
            System.out.println();
        }
    }
}",AI,Data Structures - Graph,Advanced,Graph representation using adjacency list
"import java.util.*;
class GraphDFS {
    private Map<Integer, List<Integer>> adjList;
    
    public GraphDFS() {
        adjList = new HashMap<>();
    }
    
    public void addEdge(int u, int v) {
        adjList.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
    }
    
    public void dfs(int start) {
        Set<Integer> visited = new HashSet<>();
        dfsUtil(start, visited);
    }
    
    private void dfsUtil(int vertex, Set<Integer> visited) {
        visited.add(vertex);
        System.out.print(vertex + "" "");
        for (int neighbor : adjList.getOrDefault(vertex, new ArrayList<>())) {
            if (!visited.contains(neighbor)) {
                dfsUtil(neighbor, visited);
            }
        }
    }
}",Human,Algorithms - DFS,Advanced,Depth-first search traversal
"import java.util.*;
class GraphBFS {
    private Map<Integer, List<Integer>> adjList;
    
    public GraphBFS() {
        adjList = new HashMap<>();
    }
    
    public void addEdge(int u, int v) {
        adjList.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
    }
    
    public void bfs(int start) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        visited.add(start);
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            System.out.print(vertex + "" "");
            for (int neighbor : adjList.getOrDefault(vertex, new ArrayList<>())) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
    }
}",AI,Algorithms - BFS,Advanced,Breadth-first search traversal
"import javax.swing.*;
import java.awt.event.*;
public class SimpleGUI extends JFrame {
    private JButton button;
    private JLabel label;
    
    public SimpleGUI() {
        setTitle(""Simple GUI"");
        setSize(300, 200);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(null);
        
        label = new JLabel(""Click the button"");
        label.setBounds(80, 50, 150, 30);
        add(label);
        
        button = new JButton(""Click Me"");
        button.setBounds(90, 100, 100, 30);
        button.addActionListener(e -> label.setText(""Button Clicked!""));
        add(button);
        
        setVisible(true);
    }
}",Human,Java Swing - GUI,Advanced,Simple Swing application with button
"public class DynamicProgramming {
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][capacity];
    }
}",AI,Algorithms - Dynamic Programming,Advanced,0/1 Knapsack problem solution
"public class AVLTree {
    class Node {
        int key, height;
        Node left, right;
        
        Node(int key) {
            this.key = key;
            this.height = 1;
        }
    }
    
    private Node root;
    
    private int height(Node node) {
        return node == null ? 0 : node.height;
    }
    
    private int getBalance(Node node) {
        return node == null ? 0 : height(node.left) - height(node.right);
    }
    
    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;
        x.right = y;
        y.left = T2;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        return x;
    }
    
    private Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;
        y.left = x;
        x.right = T2;
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        return y;
    }
}",Human,Data Structures - AVL Tree,Advanced,AVL tree with rotation operations
"class TrieNode {
    TrieNode[] children;
    boolean isEndOfWord;
    
    public TrieNode() {
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}

class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isEndOfWord = true;
    }
    
    public boolean search(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) return false;
            current = current.children[index];
        }
        return current.isEndOfWord;
    }
}",AI,Data Structures - Trie,Advanced,Trie implementation for word storage
"public class HeapSort {
    public void sort(int arr[]) {
        int n = arr.length;
        
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);
        
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);
        }
    }
    
    void heapify(int arr[], int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest])
            largest = left;
        
        if (right < n && arr[right] > arr[largest])
            largest = right;
        
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
            heapify(arr, n, largest);
        }
    }
}",Human,Algorithms - Heap Sort,Advanced,Heap sort with heapify operation
"public class StringManipulation {
    public static void main(String[] args) {
        String str = ""Hello World"";
        System.out.println(""Length: "" + str.length());
        System.out.println(""Uppercase: "" + str.toUpperCase());
        System.out.println(""Lowercase: "" + str.toLowerCase());
        System.out.println(""Substring: "" + str.substring(0, 5));
        System.out.println(""Replace: "" + str.replace('o', 'a'));
        System.out.println(""Contains: "" + str.contains(""World""));
        String[] words = str.split("" "");
        for (String word : words) {
            System.out.println(word);
        }
    }
}",AI,Java Strings,Beginner,String manipulation methods
"import java.io.*;
public class FileReadWrite {
    public static void writeFile(String filename, String content) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filename))) {
            writer.write(content);
            System.out.println(""File written successfully"");
        } catch (IOException e) {
            System.out.println(""Error writing file: "" + e.getMessage());
        }
    }
    
    public static void readFile(String filename) {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println(""Error reading file: "" + e.getMessage());
        }
    }
}",Human,File Processing,Intermediate,File read and write operations
"import java.util.HashSet;
public class SetOperations {
    public static void main(String[] args) {
        HashSet<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        set1.add(3);
        set1.add(4);
        
        HashSet<Integer> set2 = new HashSet<>();
        set2.add(3);
        set2.add(4);
        set2.add(5);
        set2.add(6);
        
        HashSet<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println(""Union: "" + union);
        
        HashSet<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println(""Intersection: "" + intersection);
        
        HashSet<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println(""Difference: "" + difference);
    }
}",AI,Data Structures - Set Operations,Intermediate,Set union intersection and difference
"class DoublyNode {
    int data;
    DoublyNode prev;
    DoublyNode next;
    
    DoublyNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    DoublyNode head;
    
    public void insertAtEnd(int data) {
        DoublyNode newNode = new DoublyNode(data);
        if (head == null) {
            head = newNode;
            return;
        }
        DoublyNode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
        newNode.prev = temp;
    }
    
    public void display() {
        DoublyNode temp = head;
        while (temp != null) {
            System.out.print(temp.data + "" <-> "");
            temp = temp.next;
        }
        System.out.println(""null"");
    }
}",Human,Data Structures - Doubly Linked List,Advanced,Doubly linked list implementation
"public class CircularQueue {
    private int[] queue;
    private int front, rear, size, capacity;
    
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    public boolean enqueue(int item) {
        if (isFull()) return false;
        rear = (rear + 1) % capacity;
        queue[rear] = item;
        size++;
        return true;
    }
    
    public int dequeue() {
        if (isEmpty()) return -1;
        int item = queue[front];
        front = (front + 1) % capacity;
        size--;
        return item;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}",AI,Data Structures - Circular Queue,Advanced,Circular queue implementation
"abstract class Shape {
    abstract double area();
    abstract double perimeter();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    double perimeter() {
        return 2 * Math.PI * radius;
    }
}

class Rectangle extends Shape {
    private double length, width;
    
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    double area() {
        return length * width;
    }
    
    @Override
    double perimeter() {
        return 2 * (length + width);
    }
}",Human,OOP - Abstraction,Intermediate,Abstract class with inheritance
"interface Vehicle {
    void start();
    void stop();
    int getSpeed();
}

class Car implements Vehicle {
    private int speed;
    
    public Car() {
        this.speed = 0;
    }
    
    @Override
    public void start() {
        System.out.println(""Car started"");
        speed = 10;
    }
    
    @Override
    public void stop() {
        System.out.println(""Car stopped"");
        speed = 0;
    }
    
    @Override
    public int getSpeed() {
        return speed;
    }
}",AI,OOP - Interface,Intermediate,Interface implementation
"class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void makeSound() {
        System.out.println(""Animal makes a sound"");
    }
}

class Dog extends Animal {
    private String breed;
    
    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }
    
    @Override
    public void makeSound() {
        System.out.println(name + "" barks!"");
    }
    
    public void displayInfo() {
        System.out.println(""Name: "" + name + "", Breed: "" + breed);
    }
}",Human,OOP - Inheritance,Intermediate,Inheritance with method overriding
"public class RadixSort {
    public static void radixSort(int[] arr) {
        int max = getMax(arr);
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countSort(arr, exp);
        }
    }
    
    private static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) max = arr[i];
        }
        return max;
    }
    
    private static void countSort(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
}",AI,Algorithms - Radix Sort,Advanced,Radix sort implementation
"public class TowerOfHanoi {
    public static void solveHanoi(int n, char from, char to, char aux) {
        if (n == 1) {
            System.out.println(""Move disk 1 from "" + from + "" to "" + to);
            return;
        }
        solveHanoi(n - 1, from, aux, to);
        System.out.println(""Move disk "" + n + "" from "" + from + "" to "" + to);
        solveHanoi(n - 1, aux, to, from);
    }
    
    public static void main(String[] args) {
        int n = 3;
        solveHanoi(n, 'A', 'C', 'B');
    }
}",Human,Recursion - Tower of Hanoi,Advanced,Tower of Hanoi recursive solution
"import java.util.*;
public class Dijkstra {
    class Node implements Comparable<Node> {
        int vertex;
        int distance;
        
        Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    public int[] dijkstra(int[][] graph, int source) {
        int n = graph.length;
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(source, 0));
        
        boolean[] visited = new boolean[n];
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            if (visited[u]) continue;
            visited[u] = true;
            
            for (int v = 0; v < n; v++) {
                if (graph[u][v] != 0 && !visited[v]) {
                    int newDist = dist[u] + graph[u][v];
                    if (newDist < dist[v]) {
                        dist[v] = newDist;
                        pq.offer(new Node(v, newDist));
                    }
                }
            }
        }
        return dist;
    }
}",AI,Algorithms - Dijkstra,Advanced,Dijkstra's shortest path algorithm
"class DisjointSet {
    private int[] parent;
    private int[] rank;
    
    public DisjointSet(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int xRoot = find(x);
        int yRoot = find(y);
        
        if (xRoot == yRoot) return;
        
        if (rank[xRoot] < rank[yRoot]) {
            parent[xRoot] = yRoot;
        } else if (rank[xRoot] > rank[yRoot]) {
            parent[yRoot] = xRoot;
        } else {
            parent[yRoot] = xRoot;
            rank[xRoot]++;
        }
    }
}",Human,Data Structures - Disjoint Set,Advanced,Union-Find data structure
"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class CalculatorGUI extends JFrame implements ActionListener {
    private JTextField display;
    private double num1, num2, result;
    private char operator;
    
    public CalculatorGUI() {
        setTitle(""Calculator"");
        setSize(300, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        
        display = new JTextField();
        display.setEditable(false);
        display.setFont(new Font(""Arial"", Font.BOLD, 24));
        add(display, BorderLayout.NORTH);
        
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(4, 4, 5, 5));
        
        String[] buttons = {""7"", ""8"", ""9"", ""/"", ""4"", ""5"", ""6"", ""*"", ""1"", ""2"", ""3"", ""-"", ""0"", ""C"", ""="", ""+""};
        
        for (String text : buttons) {
            JButton button = new JButton(text);
            button.setFont(new Font(""Arial"", Font.BOLD, 18));
            button.addActionListener(this);
            buttonPanel.add(button);
        }
        
        add(buttonPanel, BorderLayout.CENTER);
        setVisible(true);
    }
    
    public void actionPerformed(ActionEvent e) {
        String command = e.getActionCommand();
        
        if (command.charAt(0) >= '0' && command.charAt(0) <= '9') {
            display.setText(display.getText() + command);
        } else if (command.equals(""C"")) {
            display.setText("""");
        } else if (command.equals(""="")) {
            num2 = Double.parseDouble(display.getText());
            switch (operator) {
                case '+': result = num1 + num2; break;
                case '-': result = num1 - num2; break;
                case '*': result = num1 * num2; break;
                case '/': result = num1 / num2; break;
            }
            display.setText(String.valueOf(result));
        } else {
            num1 = Double.parseDouble(display.getText());
            operator = command.charAt(0);
            display.setText("""");
        }
    }
}",AI,Java Swing - Calculator,Advanced,GUI calculator application
"public class LongestCommonSubsequence {
    public static int lcs(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
    
    public static void main(String[] args) {
        String s1 = ""AGGTAB"";
        String s2 = ""GXTXAYB"";
        System.out.println(""LCS length: "" + lcs(s1, s2));
    }
}",Human,Algorithms - Dynamic Programming LCS,Advanced,Longest common subsequence problem
"import java.util.*;
class TopologicalSort {
    private int vertices;
    private List<List<Integer>> adjList;
    
    public TopologicalSort(int vertices) {
        this.vertices = vertices;
        adjList = new ArrayList<>(vertices);
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    public void addEdge(int u, int v) {
        adjList.get(u).add(v);
    }
    
    public void topologicalSort() {
        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[vertices];
        
        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                topologicalSortUtil(i, visited, stack);
            }
        }
        
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + "" "");
        }
    }
    
    private void topologicalSortUtil(int v, boolean[] visited, Stack<Integer> stack) {
        visited[v] = true;
        for (int neighbor : adjList.get(v)) {
            if (!visited[neighbor]) {
                topologicalSortUtil(neighbor, visited, stack);
            }
        }
        stack.push(v);
    }
}",AI,Algorithms - Topological Sort,Advanced,Topological sorting using DFS
"public class MatrixMultiplication {
    public static int[][] multiply(int[][] A, int[][] B) {
        int rowsA = A.length;
        int colsA = A[0].length;
        int colsB = B[0].length;
        
        int[][] result = new int[rowsA][colsB];
        
        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                for (int k = 0; k < colsA; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return result;
    }
    
    public static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            for (int val : row) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
    }
}",Human,Algorithms - Matrix Operations,Intermediate,Matrix multiplication algorithm

