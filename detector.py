import re
from typing import Dict, Any


def _count_comments(code: str) -> int:
    line_comments = re.findall(r"(^|\s)//.*$|(^|\s)#.*$", code, flags=re.MULTILINE)
    block_comments = re.findall(r"/\*.*?\*/|'''[\s\S]*?'''|\"\"\"[\s\S]*?\"\"\"", code, flags=re.DOTALL)
    return len(line_comments) + len(block_comments)


def _naming_style_counts(code: str) -> Dict[str, int]:
    identifiers = re.findall(r"\b[_a-zA-Z][_a-zA-Z0-9]*\b", code)
    camel = sum(1 for s in identifiers if re.search(r"[a-z][A-Z]", s) and not s.isupper())
    snake = sum(1 for s in identifiers if "_" in s and not s.isupper())
    screaming = sum(1 for s in identifiers if s.isupper() and len(s) > 2)
    return {"camel": camel, "snake": snake, "screaming": screaming, "total": len(identifiers)}


def _repetition_score(code: str) -> float:
    lines = [ln.strip() for ln in code.splitlines() if ln.strip()]
    if not lines:
        return 0.0
    freq: Dict[str, int] = {}
    for ln in lines:
        freq[ln] = freq.get(ln, 0) + 1
    max_rep = max(freq.values())
    return max(0.0, (max_rep - 1) / max(1, len(lines) - 1))


def _formatting_consistency(code: str) -> float:
    indents = []
    for ln in code.splitlines():
        if not ln.strip():
            continue
        leading_spaces = len(ln) - len(ln.lstrip(' '))
        leading_tabs = len(ln) - len(ln.lstrip('\t'))
        indents.append((leading_spaces, leading_tabs))
    if not indents:
        return 0.0
    unique = len(set(indents))
    return 1.0 - (unique / max(1, len(indents)))


def _contains_ai_markers(code: str) -> bool:
    markers = [
        "generated by",
        "chatgpt",
        "openai",
        "ai generated",
        "copilot",
        "cursor ai",
    ]
    low = code.lower()
    return any(m in low for m in markers)


def analyze_code(code: str, language: str = 'auto') -> Dict[str, Any]:
    num_lines = len(code.splitlines())
    num_chars = len(code)

    comments = _count_comments(code)
    comment_ratio = comments / max(1, num_lines)

    naming = _naming_style_counts(code)
    repetition = _repetition_score(code)
    formatting = _formatting_consistency(code)

    has_ai_markers = _contains_ai_markers(code)

    long_docstring = bool(re.search(r"'''[\s\S]{200,}'''|\"\"\"[\s\S]{200,}\"\"\"", code))

    features = {
        "lines": num_lines,
        "characters": num_chars,
        "comments": comments,
        "comment_ratio": round(comment_ratio, 3),
        "naming_camel": naming["camel"],
        "naming_snake": naming["snake"],
        "naming_screaming": naming["screaming"],
        "identifier_count": naming["total"],
        "repetition": round(repetition, 3),
        "formatting_consistency": round(formatting, 3),
        "has_ai_markers": has_ai_markers,
        "long_docstring": long_docstring,
        "language": language,
    }

    score = 0.0
    score += 25.0 if has_ai_markers else 0.0
    score += min(25.0, repetition * 25.0)
    score += min(20.0, formatting * 20.0)
    score += 10.0 if long_docstring else 0.0
    if naming["snake"] > naming["camel"] * 2 and comment_ratio < 0.03:
        score += 8.0
    if naming["camel"] > naming["snake"] * 2 and comment_ratio > 0.15:
        score -= 5.0
    score = max(0.0, min(100.0, score))

    if score >= 60:
        label = "AI-generated (likely)"
    elif score <= 40:
        label = "Human-written (likely)"
    else:
        label = "Uncertain"

    explanation = []
    if has_ai_markers:
        explanation.append("Found AI attribution markers.")
    if repetition > 0.15:
        explanation.append("Many repeated lines/blocks detected.")
    if formatting > 0.5:
        explanation.append("Highly consistent indentation/formatting.")
    if long_docstring:
        explanation.append("Contains long, polished docstrings.")
    if not explanation:
        explanation.append("Signals are mixed; classification is uncertain.")

    return {
        "label": label,
        "score": round(score, 1),
        "features": features,
        "explanation": explanation,
    } 